<!DOCTYPE html>


  
<html itemscope itemtype="https://schema.org/WebPage" class="no-js" lang="en">

<head prefix="og: http://ogp.me/ns#">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="siteBaseUrl" content="https://blog.ronan.us.kg/">
    <meta name="author" content="Ronan">
    <meta name="description" content="Bilberry Premium Theme for Hugo.">
    <meta name="keywords" content="blog,personal,responsive,search,font awesome,pages,posts,multilingual,syntax highlighting,premium,shortcuts">
    <meta name="generator" content="Hugo 0.136.2">
    <title>
        
           
               静态库与动态库 &vert; Ronan Blog
           
        
    </title>
    <meta itemprop="name" content="静态库与动态库">
    <meta itemprop="description" content="静态库与动态库 - Bilberry Premium Theme for Hugo.">
    <meta property="og:site_name" content="Ronan Blog">

    <meta property="og:url" content="https://blog.ronan.us.kg/posts/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/">
  <meta property="og:site_name" content="Ronan Blog">
  <meta property="og:title" content="静态库与动态库">
  <meta property="og:description" content="不管是Linux还是Windows中的库文件其本质和工作模式都是相同的, 只不过在不同的平台上库对应的文件格式和文件后缀不同。程序中调用的库有两种静态库和动态库，不管是哪种库文件本质是还是源文件，只不过是二进制格式只有计算机能够识别，作为一个普通人就无能为力了。
在项目中使用库一般有两个目的，一个是为了使程序更加简洁不需要在项目中维护太多的源文件，另一方面是为了源代码保密，毕竟不是所有人都想把自己编写的程序开源出来。
当我们拿到了库文件（动态库、静态库）之后要想使用还必须有这些库中提供的API函数的声明，也就是头文件，把这些都添加到项目中，就可以快乐的写代码了。
1.静态库 在Linux中静态库由程序 ar 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名规则如下:
在Linux中静态库以lib作为前缀, 以.a作为后缀, 中间是库的名字自己指定即可, 即: libxxx.a 在Windows中静态库一般以lib作为前缀, 以lib作为后缀, 中间是库的名字需要自己指定, 即: libxxx.lib 1.1生成静态链接库 生成静态库，需要先对源文件进行汇编操作 (使用参数 -c) 得到二进制格式的目标文件 (.o 格式), 然后在通过 ar工具将目标文件打包就可以得到静态库文件了 (libxxx.a)。
使用ar工具创建静态库的时候需要三个参数:
参数c：创建一个库，不管库是否存在，都将创建。 参数s：创建目标文件索引，这在创建较大的库时能加快时间。 参数r：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。 生成静态链接库的具体步骤如下:
1.需要将源文件进行汇编, 得到 .o 文件, 需要使用参数 -c
# 执行如下操作, 默认生成二进制的 .o 文件 # -c 参数位置没有要求 $ gcc 源文件(*.c) -c # 提示头文件找不到, 添加参数 -I 重新头文件路径即可 gcc 源文件(*.c) -c -I /path/ 2.将得到的 .o 进行打包, 得到静态库
$ ar rcs 静态库的名字(libxxx.a) 原材料(*.o) 3.发布静态库">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-10-22T13:28:57+08:00">
    <meta property="article:modified_time" content="2024-10-22T13:28:57+08:00">


    


    

    
    <link rel="canonical" href="https://blog.ronan.us.kg/posts/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/">
    

    

    



    
    <link id="theme-css" rel="stylesheet" href="https://blog.ronan.us.kg/theme.min.8125c5e195258aa61b74485a7c4accfba7efc242481cb11437cb6d93789d00e7.css" integrity="sha256-gSXF4ZUliqYbdEhafErM&#43;6fvwkJIHLEUN8ttk3idAOc=" media="screen" crossorigin="anonymous">



    



    

    
</head>

<body class="bilberry-hugo-theme">
    

    
    <nav>

    <div class="container">
        <ul class="topnav">
            
        </ul>

        
            <div id="search-box" class="search">
                <i class="fas fa-search"></i>
                <input id="search" type="text" placeholder="Search ...">
            </div>
        
    </div>
</nav>


    
    <header>

    <a id="back-to-top-button">
        <i class="fas fa-angle-up"></i>
    </a>

    <div class="container">
        <div class="logo">
            <a href="/" class="logo">
                
                    <img src="https://imgs.ronan.us.kg/avatar.jpg" alt="">
                

                <span class="overlay"><i class="fa fa-home"></i></span>
            </a>
        </div>
        <div class="titles">
            <h3 class="title">
                <a href="/">
                    Ronan Blog
                </a>
            </h3>

            
                <span class="subtitle">「向前每多走一步，热爱和勇气就会多一分。」</span>
            
        </div>
        <div class="selectors">
          
          
       </div>

        
            <div class="toggler">
        
                <i class="fa fa-bars" aria-hidden="true"></i>
            </div>
    </div>
    </div>
</header>


    <div class="main container">
        
    <div class="article-wrapper u-cf single">
        
            <a class="bubble" href="https://blog.ronan.us.kg/posts/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/">
    <i class="fas fa-fw fa-pencil-alt"></i>
</a>

<article class="default article">
    

    <div class="content">
    <h1 class="article-title">
        <a href="https://blog.ronan.us.kg/posts/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/">
            静态库与动态库
        </a>
    </h1>

    <div class="meta">
        
            
                <span class="date moment">2024-10-22</span>
            
        

        

        
            <span class="categories">
                
                    
                    
                        <a href="https://blog.ronan.us.kg/categories/docs/">Docs</a>
                    
                
            </span>
        

        
            <span class="author">
                
                
                    <a href="https://blog.ronan.us.kg/author/ronan/">Ronan</a>
                
            </span>
        
    </div>

    
        

        <p>不管是Linux还是Windows中的库文件其本质和工作模式都是相同的, 只不过在不同的平台上库对应的文件格式和文件后缀不同。程序中调用的库有两种<code>静态库</code>和<code>动态库</code>，不管是哪种库文件本质是还是源文件，只不过是二进制格式只有计算机能够识别，作为一个普通人就无能为力了。</p>
<p>在项目中使用库一般有两个目的，一个是为了使程序更加简洁不需要在项目中维护太多的源文件，另一方面是为了源代码保密，毕竟不是所有人都想把自己编写的程序开源出来。</p>
<p>当我们拿到了库文件（动态库、静态库）之后要想使用还必须有这些库中提供的API函数的声明，也就是头文件，把这些都添加到项目中，就可以快乐的写代码了。</p>
<h2 id="1静态库">1.静态库</h2>
<blockquote>
<p>在Linux中静态库由程序 ar 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名规则如下:</p>
</blockquote>
<ul>
<li>在Linux中静态库以lib作为前缀, 以.a作为后缀, 中间是库的名字自己指定即可, 即: libxxx.a</li>
<li>在Windows中静态库一般以lib作为前缀, 以lib作为后缀, 中间是库的名字需要自己指定, 即: libxxx.lib</li>
</ul>
<h3 id="11生成静态链接库">1.1生成静态链接库</h3>
<blockquote>
<p>生成静态库，需要先对源文件进行汇编操作 (<code>使用参数 -c</code>) 得到二进制格式的目标文件 (<code>.o 格式</code>), 然后在通过<code> ar</code>工具将目标文件打包就可以得到静态库文件了 (<code>libxxx.a</code>)。</p>
<p>使用<code>ar</code>工具创建静态库的时候需要三个参数:</p>
</blockquote>
<ul>
<li><code>参数c</code>：创建一个库，不管库是否存在，都将创建。</li>
<li><code>参数s</code>：创建目标文件索引，这在创建较大的库时能加快时间。</li>
<li><code>参数r</code>：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。</li>
</ul>
<p>
<a href="https://imgs.ronan.us.kg/lib1.png" data-dimbox data-dimbox-caption="img">
  <img alt="img" src="https://imgs.ronan.us.kg/lib1.png"/>
</a>
</p>
<p>生成静态链接库的具体步骤如下:</p>
<p>1.需要将源文件进行汇编, 得到 .o 文件, 需要使用参数 -c</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zsh" data-lang="zsh"><span style="display:flex;"><span><span style="color:#75715e"># 执行如下操作, 默认生成二进制的 .o 文件</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -c 参数位置没有要求</span>
</span></span><span style="display:flex;"><span>$ gcc 源文件<span style="color:#f92672">(</span>*.c<span style="color:#f92672">)</span> -c
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 提示头文件找不到, 添加参数 -I 重新头文件路径即可</span>
</span></span><span style="display:flex;"><span>gcc 源文件<span style="color:#f92672">(</span>*.c<span style="color:#f92672">)</span> -c -I /path/
</span></span></code></pre></div><p>2.将得到的 .o 进行打包, 得到静态库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zsh" data-lang="zsh"><span style="display:flex;"><span>$ ar rcs 静态库的名字<span style="color:#f92672">(</span>libxxx.a<span style="color:#f92672">)</span> 原材料<span style="color:#f92672">(</span>*.o<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>3.发布静态库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zsh" data-lang="zsh"><span style="display:flex;"><span><span style="color:#75715e"># 发布静态库</span>
</span></span><span style="display:flex;"><span>	1. 提供头文件 **.h
</span></span><span style="display:flex;"><span>	2. 提供制作出来的静态库 libxxx.a
</span></span></code></pre></div><h3 id="12-静态库制作举例">1.2 静态库制作举例</h3>
<h4 id="121-准备测试程序">1.2.1 准备测试程序</h4>
<p>在某个目录中有如下的源文件, 用来实现一个简单的计算器:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 目录结构 add.c div.c mult.c sub.c -&gt; 算法的源文件, 函数声明在头文件 head.h</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># main.c中是对接口的测试程序, 制作库的时候不需要将 main.c 算进去</span>
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── add.c
</span></span><span style="display:flex;"><span>├── div.c
</span></span><span style="display:flex;"><span>├── include
</span></span><span style="display:flex;"><span>│   └── head.h
</span></span><span style="display:flex;"><span>├── main.c
</span></span><span style="display:flex;"><span>├── mult.c
</span></span><span style="display:flex;"><span>└── sub.c
</span></span></code></pre></div><blockquote>
<p>加法计算源文件 add.c:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;head.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>减法计算源文件 sub.c:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;head.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">subtract</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">-</span>b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>乘法计算源文件 mult.c:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;head.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">multiply</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>除法计算的源文件 div.c</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;head.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">divide</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>)a<span style="color:#f92672">/</span>b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>头文件 head.h</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#ifndef _HEAD_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define _HEAD_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// 加法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 减法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">subtract</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 乘法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">multiply</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 除法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">divide</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><blockquote>
<p>测试文件main.c</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;head.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;a = %d, b = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, a, b);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;a + b = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">add</span>(a, b));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;a - b = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">subtract</span>(a, b));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;a * b = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">multiply</span>(a, b));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;a / b = %f</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">divide</span>(a, b));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="122-生成静态库">1.2.2 生成静态库</h4>
<p>第一步: 将源文件<code>add.c</code>, <code>div.c</code>, <code>mult.c</code>,<code> sub.c</code> 进行汇编, 得到二进制目标文件 <code>add.o</code>, <code>div.o</code>, <code>mult.o</code>, <code>sub.o</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 1. 生成.o</span>
</span></span><span style="display:flex;"><span>$ gcc add.c div.c mult.c sub.c -c
</span></span><span style="display:flex;"><span>sub.c:2:18: fatal error: head.h: No such file or directory
</span></span><span style="display:flex;"><span>compilation terminated.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 提示头文件找不到, 添加参数 -I 重新头文件路径即可</span>
</span></span><span style="display:flex;"><span>$ gcc add.c div.c mult.c sub.c -c -I ./include/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看目标文件是否已经生成</span>
</span></span><span style="display:flex;"><span>$ tree
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── add.c
</span></span><span style="display:flex;"><span>├── add.o            <span style="color:#75715e"># 目标文件</span>
</span></span><span style="display:flex;"><span>├── div.c
</span></span><span style="display:flex;"><span>├── div.o            <span style="color:#75715e"># 目标文件</span>
</span></span><span style="display:flex;"><span>├── include
</span></span><span style="display:flex;"><span>│   └── head.h
</span></span><span style="display:flex;"><span>├── main.c
</span></span><span style="display:flex;"><span>├── mult.c
</span></span><span style="display:flex;"><span>├── mult.o           <span style="color:#75715e"># 目标文件</span>
</span></span><span style="display:flex;"><span>├── sub.c
</span></span><span style="display:flex;"><span>└── sub.o            <span style="color:#75715e"># 目标文件</span>
</span></span></code></pre></div><p>第二步: 将生成的目标文件通过 <code>ar</code>工具打包生成静态库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 2. 将生成的目标文件 .o 打包成静态库</span>
</span></span><span style="display:flex;"><span>$ ar rcs libcalc.a a.o b.o c.o    <span style="color:#75715e"># a.o b.o c.o在同一个目录中可以写成 *.o</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看目录中的文件</span>
</span></span><span style="display:flex;"><span>$ tree
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── add.c
</span></span><span style="display:flex;"><span>├── add.o
</span></span><span style="display:flex;"><span>├── div.c
</span></span><span style="display:flex;"><span>├── div.o
</span></span><span style="display:flex;"><span>├── include
</span></span><span style="display:flex;"><span>│   └── <span style="color:#e6db74">`</span>head.h  <span style="color:#f92672">===</span>&gt; 和静态库一并发布
</span></span><span style="display:flex;"><span>├── <span style="color:#e6db74">`</span>libcalc.a   <span style="color:#f92672">===</span>&gt; 生成的静态库
</span></span><span style="display:flex;"><span>├── main.c
</span></span><span style="display:flex;"><span>├── mult.c
</span></span><span style="display:flex;"><span>├── mult.o
</span></span><span style="display:flex;"><span>├── sub.c
</span></span><span style="display:flex;"><span>└── sub.o
</span></span></code></pre></div><p>第三步: 将生成的的静态库 <code>libcalc.a</code>和库对应的头文件<code>head.h</code>一并发布给使用者就可以了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 3. 发布静态库</span>
</span></span><span style="display:flex;"><span>	1. head.h    <span style="color:#f92672">=</span>&gt; 函数声明
</span></span><span style="display:flex;"><span>	2. libcalc.a <span style="color:#f92672">=</span>&gt; 函数定义<span style="color:#f92672">(</span>二进制格式<span style="color:#f92672">)</span>
</span></span></code></pre></div><h3 id="13-静态库的使用">1.3 静态库的使用</h3>
<p>当我们得到了一个可用的静态库之后, 需要将其放到一个目录中, 然后根据得到的头文件编写测试代码, 对静态库中的函数进行调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 1. 首先拿到了发布的静态库</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">`</span>head.h<span style="color:#e6db74">`</span> 和 <span style="color:#e6db74">`</span>libcalc.a<span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 将静态库, 头文件, 测试程序放到一个目录中准备进行测试</span>
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── head.h          <span style="color:#75715e"># 函数声明</span>
</span></span><span style="display:flex;"><span>├── libcalc.a       <span style="color:#75715e"># 函数定义（二进制格式）</span>
</span></span><span style="display:flex;"><span>└── main.c          <span style="color:#75715e"># 函数测试</span>
</span></span></code></pre></div><p>编译测试程序, 得到可执行文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 3. 编译测试程序 main.c</span>
</span></span><span style="display:flex;"><span>$ gcc main.c -o app
</span></span><span style="display:flex;"><span>/tmp/ccR7Fk49.o: In <span style="color:#66d9ef">function</span> <span style="color:#e6db74">`</span>main<span style="color:#e6db74">&#39;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">main.c:(.text+0x38): undefined reference to `add&#39;</span>
</span></span><span style="display:flex;"><span>main.c:<span style="color:#f92672">(</span>.text+0x58<span style="color:#f92672">)</span>: undefined reference to <span style="color:#e6db74">`</span>subtract<span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">main.c:(.text+0x78): undefined reference to `multiply&#39;</span>
</span></span><span style="display:flex;"><span>main.c:<span style="color:#f92672">(</span>.text+0x98<span style="color:#f92672">)</span>: undefined reference to <span style="color:#e6db74">`</span>divide<span style="color:#960050;background-color:#1e0010">&#39;</span>
</span></span><span style="display:flex;"><span>collect2: error: ld returned <span style="color:#ae81ff">1</span> exit status
</span></span></code></pre></div><blockquote>
<p>上述错误分析:</p>
<p>编译的源文件中包含了头文件 <code>head.h</code>, 这个头文件中声明的函数对应的定义（也就是函数体实现）在静态库中，程序在编译的时候没有找到函数实现，因此提示 <code>undefined reference to xxxx</code>。</p>
<p>解决方案：在编译的时将<code>静态库的路径</code>和<code>名字</code>都指定出来</p>
<p><code> -L</code>: 指定库所在的目录(相对或者绝对路径)</p>
<p><code>-l</code>: 指定库的名字, 需要掐头(lib)去尾(.a) 剩下的才是需要的静态库的名字</p>
<p><code>-I</code>: 指定头文件所在目录</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 4. 编译的时候指定库信息</span>
</span></span><span style="display:flex;"><span>	-L: 指定库所在的目录<span style="color:#f92672">(</span>相对或者绝对路径<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>	-l: 指定库的名字, 掐头<span style="color:#f92672">(</span>lib<span style="color:#f92672">)</span>去尾<span style="color:#f92672">(</span>.a<span style="color:#f92672">)</span> <span style="color:#f92672">==</span>&gt; calc
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc</span>
</span></span><span style="display:flex;"><span>$ gcc main.c -o app -L ./ -l calc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看目录信息, 发现可执行程序已经生成了</span>
</span></span><span style="display:flex;"><span>$ tree
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── app   		<span style="color:#75715e"># 生成的可执行程序</span>
</span></span><span style="display:flex;"><span>├── head.h
</span></span><span style="display:flex;"><span>├── libcalc.a
</span></span><span style="display:flex;"><span>└── main.c
</span></span></code></pre></div><hr>
<h2 id="2-动态库">2. 动态库</h2>
<blockquote>
<p>动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可称之为共享库。</p>
<p>动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址使用的是相对地址（静态库中使用的是绝对地址），其真实地址是在应用程序加载动态库时形成的。</p>
<p>关于动态库的命名规则如下:</p>
</blockquote>
<ul>
<li>在Linux中动态库以<code>lib</code>作为前缀, 以.<code>so</code>作为后缀, 中间是库的名字自己指定即可, 即: <code>libxxx.so</code></li>
<li>在Windows中动态库一般以<code>lib</code>作为前缀, 以<code>dll</code>作为后缀, 中间是库的名字需要自己指定, 即: <code>libxxx.dll</code></li>
</ul>
<h3 id="21-生成动态链接库">2.1 生成动态链接库</h3>
<blockquote>
<p>生成动态链接库是直接使用<code>gcc</code>命令并且需要添加<code>-fPIC（-fpic）</code> 以及<code>-shared </code>参数。</p>
</blockquote>
<ul>
<li>-fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置。</li>
<li>-shared参数的作用是告诉编译器生成一个动态链接库。</li>
</ul>
<p>
<a href="https://imgs.ronan.us.kg/lib1.png" data-dimbox data-dimbox-caption="img">
  <img alt="img" src="https://imgs.ronan.us.kg/lib1.png"/>
</a>
</p>
<p>生成动态链接库的具体步骤如下:</p>
<p>1.将源文件进行汇编操作, 需要使用参数 -c, 还需要添加额外参数 -fpic / -fPIC</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 得到若干个 .o文件</span>
</span></span><span style="display:flex;"><span>$ gcc 源文件<span style="color:#f92672">(</span>*.c<span style="color:#f92672">)</span> -c -fpic
</span></span></code></pre></div><p>2.将得到的.o文件打包成动态库, 还是使用gcc, 使用参数 -shared 指定生成动态库(位置没有要求)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ gcc -shared 与位置无关的目标文件<span style="color:#f92672">(</span>*.o<span style="color:#f92672">)</span> -o 动态库<span style="color:#f92672">(</span>libxxx.so<span style="color:#f92672">)</span>
</span></span></code></pre></div><blockquote>
<p>也可以只用一条命令</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ gcc -fPIC -shared -o libadd.so *.c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add.c:2:18: fatal error: head.h: No such file or directory
</span></span><span style="display:flex;"><span>compilation terminated.
</span></span><span style="display:flex;"><span>div.c:2:18: fatal error: head.h: No such file or directory
</span></span><span style="display:flex;"><span>compilation terminated.
</span></span></code></pre></div><blockquote>
<p>以上错误可以通过-I指定头文件.h的路径解决</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>gcc -fPIC -shared -o libadd.so *.c -I ./path/
</span></span></code></pre></div><p>3.发布动态库和头文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 发布</span>
</span></span><span style="display:flex;"><span> 	1. 提供头文件: xxx.h
</span></span><span style="display:flex;"><span> 	2. 提供动态库: libxxx.so
</span></span></code></pre></div><h3 id="22-动态库制作举例">2.2 动态库制作举例</h3>
<p>在此还是以上面制作静态库使用的实例代码为例来制作动态库, 代码目录如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 举例, 示例目录如下:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 目录结构 add.c div.c mult.c sub.c -&gt; 算法的源文件, 函数声明在头文件 head.h</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># main.c中是对接口的测试程序, 制作库的时候不需要将 main.c 算进去</span>
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── add.c
</span></span><span style="display:flex;"><span>├── div.c
</span></span><span style="display:flex;"><span>├── include
</span></span><span style="display:flex;"><span>│   └── head.h
</span></span><span style="display:flex;"><span>├── main.c
</span></span><span style="display:flex;"><span>├── mult.c
</span></span><span style="display:flex;"><span>└── sub.c
</span></span></code></pre></div><p>第一步: 使用<code>gcc</code>将源文件进行<code>汇编(参数-c)</code>, 生成与位置无关的目标文件, 需要使用参数 <code>-fpic</code>或者<code>-fPIC</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC</span>
</span></span><span style="display:flex;"><span>$ gcc add.c div.c mult.c sub.c -c -fpic -I ./include/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看目录文件信息, 检查是否生成了目标文件</span>
</span></span><span style="display:flex;"><span>$ tree
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── add.c
</span></span><span style="display:flex;"><span>├── add.o                <span style="color:#75715e"># 生成的目标文件</span>
</span></span><span style="display:flex;"><span>├── div.c
</span></span><span style="display:flex;"><span>├── div.o                <span style="color:#75715e"># 生成的目标文件</span>
</span></span><span style="display:flex;"><span>├── include
</span></span><span style="display:flex;"><span>│   └── head.h
</span></span><span style="display:flex;"><span>├── main.c
</span></span><span style="display:flex;"><span>├── mult.c
</span></span><span style="display:flex;"><span>├── mult.o               <span style="color:#75715e"># 生成的目标文件</span>
</span></span><span style="display:flex;"><span>├── sub.c
</span></span><span style="display:flex;"><span>└── sub.o                <span style="color:#75715e"># 生成的目标文件</span>
</span></span></code></pre></div><p>第二步: 使用<code>gcc</code>将得到的目标文件打包生成动态库, 需要使用参数 <code>-shared</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared</span>
</span></span><span style="display:flex;"><span>$ gcc -shared add.o div.o mult.o sub.o -o libcalc.so
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查目录中是否生成了动态库</span>
</span></span><span style="display:flex;"><span>$ tree
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── add.c
</span></span><span style="display:flex;"><span>├── add.o
</span></span><span style="display:flex;"><span>├── div.c
</span></span><span style="display:flex;"><span>├── div.o
</span></span><span style="display:flex;"><span>├── include
</span></span><span style="display:flex;"><span>│   └── <span style="color:#e6db74">`</span>head.h   <span style="color:#f92672">===</span>&gt; 和动态库一起发布
</span></span><span style="display:flex;"><span>├── <span style="color:#e6db74">`</span>libcalc.so   <span style="color:#f92672">===</span>&gt; 生成的动态库
</span></span><span style="display:flex;"><span>├── main.c
</span></span><span style="display:flex;"><span>├── mult.c
</span></span><span style="display:flex;"><span>├── mult.o
</span></span><span style="display:flex;"><span>├── sub.c
</span></span><span style="display:flex;"><span>└── sub.o
</span></span></code></pre></div><p>第三步: 发布生成的动态库和相关的头文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 3. 发布库文件和头文件</span>
</span></span><span style="display:flex;"><span>	1. head.h
</span></span><span style="display:flex;"><span>	2. libcalc.so
</span></span></code></pre></div><h3 id="23-动态库的使用">2.3 动态库的使用</h3>
<p>当我们得到了一个可用的动态库之后, 需要将其放到一个目录中, 然后根据得到的头文件编写测试代码, 对动态库中的函数进行调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 1. 拿到发布的动态库</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">`</span>head.h   libcalc.so
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">`</span>main.c<span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 示例目录:</span>
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── head.h          <span style="color:#f92672">==</span>&gt; 函数声明
</span></span><span style="display:flex;"><span>├── libcalc.so      <span style="color:#f92672">==</span>&gt; 函数定义
</span></span><span style="display:flex;"><span>└── main.c          <span style="color:#f92672">==</span>&gt; 函数测试
</span></span></code></pre></div><p>编译测试程序</p>
<pre tabindex="0"><code class="language-she" data-lang="she"># 3. 编译测试程序
$ gcc main.c -o app
/tmp/ccwlUpVy.o: In function `main&#39;:
main.c:(.text+0x38): undefined reference to `add&#39;
main.c:(.text+0x58): undefined reference to `subtract&#39;
main.c:(.text+0x78): undefined reference to `multiply&#39;
main.c:(.text+0x98): undefined reference to `divide&#39;
collect2: error: ld returned 1 exit status
</code></pre><blockquote>
<p>错误原因:</p>
<p>和使用静态库一样, 在编译的时候需要指定库相关的信息: <code>库的路径 -L</code>和 <code>库的名字 -l</code></p>
</blockquote>
<p>添加库信息相关参数, 重新编译测试代码:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 在编译的时候指定动态库相关的信息: 库的路径 -L, 库的名字 -l</span>
</span></span><span style="display:flex;"><span>$ gcc main.c -o app -L./ -lcalc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看是否生成了可执行程序</span>
</span></span><span style="display:flex;"><span>$ tree
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>├── app 			<span style="color:#75715e"># 生成的可执行程序</span>
</span></span><span style="display:flex;"><span>├── head.h
</span></span><span style="display:flex;"><span>├── libcalc.so
</span></span><span style="display:flex;"><span>└── main.c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 执行生成的可执行程序, 错误提示 ==&gt; 可执行程序执行的时候找不到动态库</span>
</span></span><span style="display:flex;"><span>$ ./app
</span></span><span style="display:flex;"><span>./app: error <span style="color:#66d9ef">while</span> loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory
</span></span></code></pre></div><blockquote>
<p>关于整个操作过程的报告：</p>
<p>gcc通过指定的动态库信息生成了可执行程序, 但是可执行程序运行却提示<code>无法加载到动态库</code>。</p>
</blockquote>
<h3 id="24-解决动态库无法加载问题">2.4 解决动态库无法加载问题</h3>
<h4 id="241-库的工作原理">2.4.1 库的工作原理</h4>
<ul>
<li>
<p>静态库如何被加载:</p>
<p>在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。</p>
</li>
<li>
<p>动态库如何被加载</p>
<ul>
<li>
<p>在程序编译的最后一个阶段也就是链接阶段：</p>
<ul>
<li>在gcc命令中虽然指定了库路径(<code>使用参数 -L </code>), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。</li>
<li>同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。</li>
</ul>
</li>
<li>
<p>可执行程序被执行起来之后:</p>
<ul>
<li>程序执行的时候会<code>先检测</code>需要的动态库是否可以被加载，加载不到就会提示上边的错误信息</li>
<li><code>当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载</code></li>
<li>动态库的检测和内存加载操作都是由动态连接器来完成的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="242-动态链接器">2.4.2 动态链接器</h4>
<blockquote>
<p>动态链接器是一个独立于应用程序的进程, 属于操作系统, 当用户的程序需要加载动态库的时候动态连接器就开始工作了，很显然动态连接器根本就不知道用户通过 gcc 编译程序的时候通过参数 -L指定的路径。</p>
<p>那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：</p>
</blockquote>
<p>1.可执行文件内部的 <code>DT_RPATH</code> 段</p>
<p>2.系统的环境变量 <code>LD_LIBRARY_PATH</code></p>
<p>3.系统动态库的缓存文件 <code>/etc/ld.so.cache</code></p>
<p>4.存储动态库/静态库的系统目录<code> /lib/</code>, <code>/usr/lib</code>等
按照以上四个顺序, 依次搜索, 找到之后结束遍历, 最终还是没找到, 动态连接器就会提示动态库找不到的错误信息。</p>
<h4 id="243-解决方案">2.4.3 解决方案</h4>
<blockquote>
<p>可执行程序生成之后, 根据动态链接器的搜索路径, 我们可以提供三种解决方案，我们只需要将动态库的路径放到对应的环境变量或者系统配置文件中，同样也可以将动态库拷贝到系统库目录（或者是将动态库的软链接文件放到这些系统库目录中）。</p>
</blockquote>
<h5 id="方案1">方案1</h5>
<p>将库路径添加到环境变量 <code>LD_LIBRARY_PATH</code> 中</p>
<p>1.找到相关的配置文件</p>
<pre><code> `用户级别: ~/.bashrc` —&gt; 设置对当前用户有效

 `系统级别: /etc/profile` —&gt; 设置对所有用户有效
</code></pre>
<p>2.使用 vim 打开配置文件, 在文件最后添加这样一句话</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 自己把路径写进去就行了</span>
</span></span><span style="display:flex;"><span>export LD_LIBRARY_PATH<span style="color:#f92672">=</span>$LD_LIBRARY_PATH:动态库的绝对路径
</span></span></code></pre></div><p>3.让修改的配置文件生效</p>
<ul>
<li>修改了用户级别的配置文件, 关闭当前终端, 打开一个新的终端配置就生效了</li>
<li>修改了系统级别的配置文件, 注销或关闭系统, 再开机配置就生效了</li>
<li>不想执行上边的操作, 可以执行一个命令让配置重新被加载</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 修改的是哪一个就执行对应的那个命令</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># source 可以简写为一个 . , 作用是让文件内容被重新加载</span>
</span></span><span style="display:flex;"><span>$ source ~/.bashrc          <span style="color:#f92672">(</span>. ~/.bashrc<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>$ source /etc/profile       <span style="color:#f92672">(</span>. /etc/profile<span style="color:#f92672">)</span>
</span></span></code></pre></div><h5 id="方案2">方案2</h5>
<p>更新 /etc/ld.so.cache 文件</p>
<p>1.找到动态库所在的绝对路径（不包括库的名字）比如：<code>/home/robin/Library/</code></p>
<p>2.使用vim 修改 <code>/etc/ld.so.conf </code>这个文件, 将上边的路径添加到文件中(独自占一行)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 1. 打开文件</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/ld.so.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 添加动态库路径, 并保存退出</span>
</span></span></code></pre></div><p>3.更新 <code>/etc/ld.so.conf</code>中的数据到 <code>/etc/ld.so.cache</code> 中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 必须使用管理员权限执行这个命令</span>
</span></span><span style="display:flex;"><span>sudo ldconfig
</span></span></code></pre></div><h5 id="方案3">方案3</h5>
<p>拷贝动态库文件到系统库目录 <code>/lib/</code> 或者 <code>/usr/lib </code>中 (或者将库的软链接文件放进去)，<code>以下二选一</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 库拷贝</span>
</span></span><span style="display:flex;"><span>sudo cp /xxx/xxx/libxxx.so /usr/lib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建软连接</span>
</span></span><span style="display:flex;"><span>sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so
</span></span></code></pre></div><h5 id="方案4">方案4</h5>
<p>如果上述方法仍然不行，可以在运行时指定搜索路径：尝试在编译时使用 <code>-Wl,-rpath</code> 选项指定共享库的运行时搜索路径，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>gcc main.c -o app -L./ -ltest -Wl,-rpath,/path/library
</span></span></code></pre></div><h4 id="244-验证">2.4.4 验证</h4>
<p>在启动可执行程序之前, 或者在设置了动态库路径之后, 我们可以通过一个命令检测程序能不能够通过动态链接器加载到对应的动态库, 这个命令叫做<code> ldd</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 语法:</span>
</span></span><span style="display:flex;"><span>$ ldd 可执行程序名
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 举例:</span>
</span></span><span style="display:flex;"><span>$ ldd app
</span></span><span style="display:flex;"><span>	linux-vdso.so.1 <span style="color:#f92672">=</span>&gt;  <span style="color:#f92672">(</span>0x00007ffe8fbd6000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    libcalc.so <span style="color:#f92672">=</span>&gt; /home/robin/Linux/3Day/calc/test/libcalc.so <span style="color:#f92672">(</span>0x00007f5d85dd4000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    libc.so.6 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style="color:#f92672">(</span>0x00007f5d85a0a000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    /lib64/ld-linux-x86-64.so.2 <span style="color:#f92672">(</span>0x00007f5d85fd6000<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span>&gt; 动态链接器, 操作系统提供
</span></span></code></pre></div><hr>
<h2 id="3优缺点">3.优缺点</h2>
<h4 id="31-静态库">3.1 静态库</h4>
<p>优点：
静态库被打包到应用程序中加载速度快
发布程序无需提供静态库，移植方便</p>
<p>缺点：
相同的库文件数据可能在内存中被加载多份, 消耗系统资源，浪费内存
库文件更新需要重新编译项目文件, 生成新的可执行程序, 浪费时间。</p>
<p>
<a href="https://imgs.ronan.us.kg/lib1.png" data-dimbox data-dimbox-caption="img">
  <img alt="img" src="https://imgs.ronan.us.kg/lib1.png"/>
</a>
</p>
<h4 id="32-动态库">3.2 动态库</h4>
<p>优点：</p>
<pre><code>可实现不同进程间的资源共享
		动态库升级简单, 只需要替换库文件, 无需重新编译应用程序
		程序猿可以控制何时加载动态库, 不调用库函数动态库不会被加载
</code></pre>
<p>缺点：</p>
<pre><code>加载速度比静态库慢, 以现在计算机的性能可以忽略
		发布程序需要提供依赖的动态库
</code></pre>
<p>
<a href="https://imgs.ronan.us.kg/lib1.1.png" data-dimbox data-dimbox-caption="img">
  <img alt="img" src="https://imgs.ronan.us.kg/lib1.1.png"/>
</a>
</p>

    
</div>

    
<div class="footer no-tags">


    

    
</div>

</article>

        
    </div>

    
        <div id="comments-container">
            
            

            

            

        </div>
    

    </div>

    
<footer>
    <div class="container">

        
        <div class="recent-posts">
            <strong>Latest posts</strong>
            <ul>
                
                
                    <li>
                        <a href="https://blog.ronan.us.kg/posts/pyinstaller%E5%B0%86python%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85%E4%B8%BAandroid%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">PyInstaller将Python应用打包为Android应用程序</a>
                    </li>
                
                    <li>
                        <a href="https://blog.ronan.us.kg/posts/gmeek%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC%E5%8D%95%E7%AF%87%E6%88%96%E6%89%B9%E9%87%8F/">「Gmeek」上传脚本(单篇或批量)</a>
                    </li>
                
                    <li>
                        <a href="https://blog.ronan.us.kg/posts/platformioprintf-%E9%87%8D%E6%98%A0%E5%83%8F%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0%E6%95%B0%E6%8D%AE/">「platformIO」printf 重映像、串口打印数据</a>
                    </li>
                
                    <li>
                        <a href="https://blog.ronan.us.kg/posts/python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/">「Python」模块和包</a>
                    </li>
                
                    <li>
                        <a href="https://blog.ronan.us.kg/posts/pythonconda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/">「python」Conda虚拟环境</a>
                    </li>
                
                    <li>
                        <a href="https://blog.ronan.us.kg/posts/python%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90requirements.txt%E7%9A%84%E5%BA%93/">「python」一个快速生成requirements.txt的库</a>
                    </li>
                
                    <li>
                        <a href="https://blog.ronan.us.kg/posts/orbstackmac-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%BF%AB%E7%9A%84-docker-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E5%8F%AF%E5%AE%8C%E5%85%A8%E6%9B%BF%E4%BB%A3-docker-desktop/">「OrbStack」Mac 系统中一个更快的 Docker 可视化工具，可完全替代 Docker Desktop</a>
                    </li>
                
            </ul>
        </div>
        

        
        <div class="categories">
            
            <a href="https://blog.ronan.us.kg/categories/"><strong>Categories</strong></a>
            

            <ul>
                
                <li>
                
                    <a href="https://blog.ronan.us.kg/categories/docs/">Docs (38)</a>
                
                </li>
                
                <li>
                
                    <a href="https://blog.ronan.us.kg/categories/linux/">Linux (11)</a>
                
                </li>
                
                <li>
                
                    <a href="https://blog.ronan.us.kg/categories/macos/">Macos (5)</a>
                
                </li>
                
                <li>
                
                    <a href="https://blog.ronan.us.kg/categories/tools/">Tools (5)</a>
                
                </li>
                
                <li>
                
                    <a href="https://blog.ronan.us.kg/categories/vscode/">Vscode (4)</a>
                
                </li>
                
            </ul>
        </div>
        

        <div class="right">
            
            <div class="external-profiles">
                <strong>Social media</strong>
                
                <a href="https://weibo.com/u/5995159469" target="_blank" rel="me"><em class="fab fa-weibo"></em></a>
                
                <a href="https://github.com/EchoZap" target="_blank" rel=""><em class="fab fa-github"></em></a>
                
            </div>
            

            

            
            <div class="archive">
                
                <a href="https://blog.ronan.us.kg/archive/"><strong>Archive</strong></a>
                
            </div>
            
        </div>
    </div>
</footer>


<div class="credits">
    <div class="container">
        <div class="copyright">
            <a href="https://github.com/echozap" target="_blank">
                &copy;
                
                2024
                
                by Ronan
            </a>
            
        </div>
        <div class="author">
            <a href="https://github.com/Lednerb/bilberry-hugo-theme"
                target="_blank">Bilberry Hugo Theme</a>
        </div>
    </div>
</div>


    

    

    


    

    

    

    

    

    

    

    



    
    
    



    
    







    
    <script src="https://blog.ronan.us.kg/theme.min.15a051027515397e36946f37800e8a370e44f72ac97de37ae55b55087e3b0b59.js" integrity="sha256-FaBRAnUVOX42lG83gA6KNw5E9yrJfeN65VtVCH47C1k=" crossorigin="anonymous"></script>



    



    
        <div id="activate-algolia-search" class="hidden">
  <input type="hidden" id="algolia-search-appId" value="GT5UPRMBE6">
  <input type="hidden" id="algolia-search-apiKey" value="9499608ea45258a283445ca59ad50c14">
  <input type="hidden" id="algolia-search-indexName" value="hugo">
  <input type="hidden" id="algolia-search-noSearchResults" value="Nothing found.">

  
  <input type="hidden" id="algolia-search-currentLanguageOnly">
  
</div>

    

    
</body>

</html>
